// Auto-generated by scripts/generate_bundled_libraries.js - do not edit manually
// Contains all .sld and .scm files from src/core/scheme/ and src/extras/scheme/

export const BUNDLED_SOURCES = {
  "base.sld": ";; R7RS (scheme base) library\n;; \n;; This re-exports primitives from the runtime and core implementations.\n;; Per R7RS Appendix A.\n\n(define-library (scheme base)\n  (import (scheme primitives))\n  (import (scheme core))\n  (import (scheme control))\n\n  (export\n    ;; Equivalence predicates\n    eq? eqv? equal?\n    \n    ;; Numbers - basic arithmetic\n    + - * /\n    \n    ;; Numbers - comparison (variadic, from core)\n    = < > <= >=\n    \n    ;; Numbers - predicates (from primitives)\n    number? complex? real? rational? integer? exact-integer?\n    exact? inexact?\n    finite? infinite? nan?\n    \n    ;; Numbers - predicates (from core)\n    zero? positive? negative? odd? even?\n    \n    ;; Numbers - operations\n    abs quotient remainder modulo\n    floor ceiling truncate round\n    max min gcd lcm\n    expt sqrt square\n    exact-integer-sqrt\n    exact inexact\n    floor/ floor-quotient floor-remainder\n    truncate/ truncate-quotient truncate-remainder\n    \n    ;; Rational number procedures\n    numerator denominator\n    \n    ;; Complex number procedures\n    make-rectangular make-polar\n    real-part imag-part magnitude angle\n    \n    ;; Bytevectors\n    bytevector? make-bytevector bytevector bytevector-length\n    bytevector-u8-ref bytevector-u8-set!\n    bytevector-copy bytevector-copy! bytevector-append\n    utf8->string string->utf8\n    \n    ;; Booleans\n    not boolean? boolean=?\n    \n    ;; Pairs and lists - basic\n    cons car cdr pair? null? list?\n    set-car! set-cdr!\n    list append\n    \n    ;; Pairs and lists - extended\n    length list-ref list-tail reverse list-copy\n    make-list list-set!\n    memq memv member\n    assq assv assoc\n    \n    ;; Compound accessors (cxr) - depth 2-4\n    caar cadr cdar cddr\n    caaar caadr cadar caddr cdaar cdadr cddar cdddr\n    caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr\n    cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr\n    \n    ;; Symbols\n    symbol? symbol=? symbol->string string->symbol\n    \n    ;; Characters\n    char? char=? char<? char>? char<=? char>=?\n    char->integer integer->char\n    \n    ;; Strings  \n    string? make-string string string-length string-ref\n    string=? string<? string>? string<=? string>=?\n    substring string-append string-copy\n    string->list list->string\n    number->string string->number\n    string-upcase string-downcase string-foldcase\n    \n    ;; Vectors\n    vector? make-vector vector vector-length\n    vector-ref vector-set! vector-fill!\n    vector-copy vector-copy! vector-append\n    vector->list list->vector\n    vector->string string->vector\n    \n    ;; Control\n    apply map for-each\n    string-map string-for-each\n    vector-map vector-for-each\n    call-with-current-continuation call/cc\n    dynamic-wind\n    values call-with-values\n    procedure?\n    make-parameter parameterize param-dynamic-bind\n    \n    ;; Exceptions\n    raise raise-continuable\n    with-exception-handler\n    error\n    error-object? error-object-message error-object-irritants\n    \n    ;; I/O - Ports\n    port? input-port? output-port?\n    textual-port? binary-port?\n    input-port-open? output-port-open?\n    current-input-port current-output-port current-error-port\n    close-port close-input-port close-output-port\n    flush-output-port\n    \n    ;; I/O - String Ports\n    open-input-string open-output-string get-output-string\n    \n    ;; I/O - Bytevector Ports (Binary I/O)\n    open-input-bytevector open-output-bytevector get-output-bytevector\n    \n    ;; I/O - EOF\n    eof-object eof-object?\n    \n    ;; I/O - Input\n    read-char peek-char char-ready?\n    read-line read-string\n    read\n    \n    ;; I/O - Binary Input\n    read-u8 peek-u8 u8-ready?\n    read-bytevector\n    \n    ;; I/O - Output\n    write-char write-string\n    display newline write\n    write-simple write-shared\n    \n    ;; I/O - Binary Output\n    write-u8 write-bytevector\n    \n    ;; Syntax (Macros & Special Forms)\n    define set! lambda if begin quote quasiquote unquote unquote-splicing\n    define-syntax let-syntax letrec-syntax\n    and or cond case do when unless guard\n    let let* letrec letrec*\n    let-values let*-values define-values\n    define-record-type\n    define-class\n  )\n  \n  ;; The actual bindings come from the runtime primitives.\n  ;; This library just declares what (scheme base) exports.\n  (begin\n    ;; No definitions needed - primitives are injected by the runtime\n  ))\n",
  "case-lambda.sld": ";; (scheme case-lambda) library\n;;\n;; R7RS library providing case-lambda for multi-arity procedures.\n\n(define-library (scheme case-lambda)\n  (import (scheme base))\n  (export case-lambda)\n  (include \"case_lambda.scm\"))\n",
  "case_lambda.scm": ";; case-lambda - Multi-arity procedure definition\n;;\n;; R7RS (scheme case-lambda) library\n;;\n;; case-lambda creates a procedure that dispatches based on argument count.\n;; Example:\n;;   (define add\n;;     (case-lambda\n;;       (() 0)\n;;       ((x) x)\n;;       ((x y) (+ x y))))\n\n;; /**\n;;  * case-lambda macro\n;;  *\n;;  * Creates a procedure that selects a clause based on argument count.\n;;  * Uses a simple nested-if approach for dispatching.\n;;  *\n;;  * @syntax (case-lambda clause ...)\n;;  * @param clause - (formals body ...) where formals is a lambda parameter list\n;;  * @returns A procedure that dispatches on arity\n;;  */\n\n;; Simple implementation: expand to cond-based dispatch on length\n;; For (case-lambda (()  body0) ((x) body1) ((x y) body2))\n;; expands to:\n;; (lambda args\n;;   (let ((n (length args)))\n;;     (cond\n;;       ((= n 0) body0)\n;;       ((= n 1) (let ((x (car args))) body1))\n;;       ((= n 2) (let ((x (car args)) (y (cadr args))) body2))\n;;       (else (error \"no matching clause\")))))\n\n(define-syntax case-lambda\n  (syntax-rules ()\n    ;; Single clause - optimize to simple lambda\n    ((case-lambda (formals body ...))\n     (lambda formals body ...))\n    \n    ;; Multiple clauses - build generic dispatcher\n    ((case-lambda clause ...)\n     (lambda args\n       (case-lambda-clauses args clause ...)))))\n\n;; Helper: expand clauses to cond-like dispatch\n(define-syntax case-lambda-clauses\n  (syntax-rules ()\n    ;; Base: no more clauses, error\n    ((case-lambda-clauses args)\n     (error \"case-lambda: no matching clause\" (length args)))\n    \n    ;; Empty formals: 0 args\n    ((case-lambda-clauses args (() body ...) rest ...)\n     (if (null? args)\n         (begin body ...)\n         (case-lambda-clauses args rest ...)))\n    \n    ;; One param\n    ((case-lambda-clauses args ((a) body ...) rest ...)\n     (if (and (pair? args) (null? (cdr args)))\n         (let ((a (car args)))\n           body ...)\n         (case-lambda-clauses args rest ...)))\n    \n    ;; Two params\n    ((case-lambda-clauses args ((a b) body ...) rest ...)\n     (if (and (pair? args) (pair? (cdr args)) (null? (cddr args)))\n         (let ((a (car args)) (b (cadr args)))\n           body ...)\n         (case-lambda-clauses args rest ...)))\n    \n    ;; Three params\n    ((case-lambda-clauses args ((a b c) body ...) rest ...)\n     (if (and (pair? args) (pair? (cdr args)) (pair? (cddr args)) (null? (cdddr args)))\n         (let ((a (car args)) (b (cadr args)) (c (caddr args)))\n           body ...)\n         (case-lambda-clauses args rest ...)))\n    \n    ;; Four params\n    ((case-lambda-clauses args ((a b c d) body ...) rest ...)\n     (if (= (length args) 4)\n         (let ((a (car args)) (b (cadr args)) (c (caddr args)) (d (cadddr args)))\n           body ...)\n         (case-lambda-clauses args rest ...)))\n    \n    ;; NOTE: Rest patterns must be ordered from most specific to least specific\n    ;; to ensure proper pattern matching.\n    \n    ;; Three or more (rest param) - must come before (a b . rest)\n    ((case-lambda-clauses args ((a b c . rest) body ...) more ...)\n     (if (and (pair? args) (pair? (cdr args)) (pair? (cddr args)))\n         (let ((a (car args)) (b (cadr args)) (c (caddr args)) (rest (cdddr args)))\n           body ...)\n         (case-lambda-clauses args more ...)))\n    \n    ;; Two or more (rest param) - must come before (a . rest)\n    ((case-lambda-clauses args ((a b . rest) body ...) more ...)\n     (if (and (pair? args) (pair? (cdr args)))\n         (let ((a (car args)) (b (cadr args)) (rest (cddr args)))\n           body ...)\n         (case-lambda-clauses args more ...)))\n    \n    ;; One or more (rest param)\n    ((case-lambda-clauses args ((a . rest) body ...) more ...)\n     (if (pair? args)\n         (let ((a (car args)) (rest (cdr args)))\n           body ...)\n         (case-lambda-clauses args more ...)))\n    \n    ;; Pure rest param (matches anything) - must be last\n    ((case-lambda-clauses args (rest body ...) more ...)\n     (let ((rest args))\n       body ...))))\n",
  "char.sld": ";; R7RS (scheme char) library\n;; \n;; Character procedures that are not in (scheme base).\n;; Per R7RS Appendix A.\n\n(define-library (scheme char)\n  (import (scheme primitives))\n  \n  (export\n    ;; Case-insensitive comparison\n    char-ci=? char-ci<? char-ci>? char-ci<=? char-ci>=?\n    \n    ;; Character class predicates\n    char-alphabetic? char-numeric? char-whitespace?\n    char-upper-case? char-lower-case?\n    \n    ;; Case conversion\n    char-upcase char-downcase char-foldcase\n    \n    ;; Digit value\n    digit-value\n  )\n  \n  (begin\n    ;; No definitions needed - primitives are injected by the runtime\n  ))\n",
  "complex.sld": ";; R7RS (scheme complex) library\n;;\n;; This library re-exports the optional complex number procedures.\n;; They are already implemented in (scheme base) in this implementation,\n;; but R7RS allows them to be in a separate library.\n\n(define-library (scheme complex)\n  (import (scheme base))\n  (export\n    make-rectangular\n    make-polar\n    real-part\n    imag-part\n    magnitude\n    angle))\n",
  "control.scm": ";; Standard Control Macros\n;; (when, unless, do, case, guard, let-values, let*-values, define-values)\n;; Note: `or` and `let*` are defined in macros.scm\n\n;; /**\n;;  * One-armed conditional.\n;;  * Evaluates body if test is true.\n;;  *\n;;  * @param {expression} test - Conditional test.\n;;  * @param {...expression} body - Expressions to evaluate if test is true.\n;;  */\n(define-syntax when\n  (syntax-rules ()\n    ((when test result1 result2 ...)\n     (if test\n         (begin result1 result2 ...)))))\n\n;; /**\n;;  * One-armed conditional (negated).\n;;  * Evaluates body if test is false.\n;;  *\n;;  * @param {expression} test - Conditional test.\n;;  * @param {...expression} body - Expressions to evaluate if test is false.\n;;  */\n(define-syntax unless\n  (syntax-rules ()\n    ((unless test result1 result2 ...)\n     (if test\n         #f ;; unspecified\n         (begin result1 result2 ...)))))\n\n;; /**\n;;  * Iteration construct.\n;;  *\n;;  * @param {list} ((var init [step]) ...) - Variable bindings.\n;;  * @param {list} (test expression ...) - Termination condition and return value.\n;;  * @param {...expression} commands - Body expressions.\n;;  */\n\n(define-syntax do\n  (syntax-rules ()\n    ;; Normalizer: (var init step) -> keep as is\n    ((do \"normalize\" ((var init step) . rest) (done ...) clause . body)\n     (do \"normalize\" rest (done ... (var init step)) clause . body))\n    \n    ;; Normalizer: (var init) -> add var as step\n    ((do \"normalize\" ((var init) . rest) (done ...) clause . body)\n     (do \"normalize\" rest (done ... (var init var)) clause . body))\n\n    ;; Base case: all normalized, generate loop\n    ((do \"normalize\" () ((var init step) ...) (test expr ...) . body)\n     (letrec\n       ((loop\n         (lambda (var ...)\n           (if test\n               (begin\n                 (if #f #f)\n                 expr ...)\n               (begin\n                 (begin . body)\n                 (loop step ...))))))\n       (loop init ...)))\n\n    ;; Entry point: start normalizing bindings\n    ((do ((var init . step) ...) (test . exprs) . commands)\n     (do \"normalize\" ((var init . step) ...) () (test . exprs) . commands))))\n\n;; =============================================================================\n;; Multiple Value Binding Forms\n;; =============================================================================\n\n;; /**\n;;  * Let-values binding form.\n;;  * Binds results from producers that return multiple values.\n;;  *\n;;  * @param {list} ((formals producer) ...) - Binding clauses.\n;;  * @param {...expression} body - Body expressions.\n;;  */\n(define-syntax let-values\n  (syntax-rules ()\n    ;; Empty bindings\n    ((let-values () body ...)\n     (let () body ...))\n    ;; Single binding\n    ((let-values ((formals producer)) body ...)\n     (call-with-values\n       (lambda () producer)\n       (lambda formals body ...)))\n    ;; Multiple bindings - nest them\n    ((let-values ((formals producer) rest ...) body ...)\n     (call-with-values\n       (lambda () producer)\n       (lambda formals (let-values (rest ...) body ...))))))\n\n;; /**\n;;  * Sequential let-values binding form.\n;;  * Like let-values but each clause sees the bindings of previous clauses.\n;;  *\n;;  * @param {list} ((formals producer) ...) - Binding clauses.\n;;  * @param {...expression} body - Body expressions.\n;;  */\n(define-syntax let*-values\n  (syntax-rules ()\n    ;; Empty bindings\n    ((let*-values () body ...)\n     (let () body ...))\n    ;; One or more bindings - expand sequentially\n    ((let*-values ((formals producer) rest ...) body ...)\n     (call-with-values\n       (lambda () producer)\n       (lambda formals (let*-values (rest ...) body ...))))))\n\n;; /**\n;;  * Define multiple variables from multiple values.\n;;  * Uses a recursive pattern to support any number of variables.\n;;  * Supports: (define-values () expr), (define-values (a b c ...) expr),\n;;  * (define-values (a b . rest) expr), (define-values name expr).\n;;  *\n;;  * @param {list|symbol} formals - Variable(s) to define.\n;;  * @param {expression} expr - Expression producing multiple values.\n;;  */\n(define-syntax define-values\n  (syntax-rules ()\n    ;; Empty formals - just evaluate for side effects\n    ((define-values () expr)\n     (call-with-values (lambda () expr) (lambda () (if #f #f))))\n\n    ;; Single variable in parens - direct assignment\n    ((define-values (var) expr)\n     (define var (call-with-values (lambda () expr) (lambda (x) x))))\n\n    ;; Multiple variables without rest - use recursive helper\n    ;; First capture all values as a list, then extract each one\n    ((define-values (var0 var1 ...) expr)\n     (begin\n       (define temp-vals (call-with-values (lambda () expr) list))\n       (define-values \"extract\" (var0 var1 ...) temp-vals)))\n\n    ;; Rest variable pattern: (a b . rest)\n    ((define-values (var0 var1 ... . rest) expr)\n     (begin\n       (define temp-vals (call-with-values (lambda () expr) list))\n       (define-values \"extract-rest\" (var0 var1 ...) rest temp-vals)))\n\n    ;; Single variable without parens (gets all values as list)\n    ;; NOTE: This pattern must be LAST as bare `var` matches any expression\n    ((define-values var expr)\n     (define var (call-with-values (lambda () expr) list)))\n\n    ;; Recursive extraction helper - base case\n    ((define-values \"extract\" (var) temp-vals)\n     (define var (car temp-vals)))\n\n    ;; Recursive extraction helper - multiple remaining\n    ((define-values \"extract\" (var0 var1 ...) temp-vals)\n     (begin\n       (define var0 (car temp-vals))\n       (define-values \"extract\" (var1 ...) (cdr temp-vals))))\n\n    ;; Rest extraction helper - base case (no more regular vars)\n    ((define-values \"extract-rest\" () rest temp-vals)\n     (define rest temp-vals))\n\n    ;; Rest extraction helper - extract one var, continue\n    ((define-values \"extract-rest\" (var0 var1 ...) rest temp-vals)\n     (begin\n       (define var0 (car temp-vals))\n       (define-values \"extract-rest\" (var1 ...) rest (cdr temp-vals))))))\n\n;; /**\n;;  * Case dispatch.\n;;  * Dispatches based on value equality (using memv).\n;;  * Supports => syntax to apply a procedure to the matched key.\n;;  *\n;;  * @param {expression} key - Value to match.\n;;  * @param {...list} clauses - ((datum ...) result1 result2 ...) or ((datum ...) => proc).\n;;  */\n(define-syntax case\n  (syntax-rules (else =>)\n    ;; else with => - apply proc to key (must come before plain else)\n    ((case \"dispatch\" key\n       (else => proc))\n     (proc key))\n    ;; else clause - always matches\n    ((case \"dispatch\" key\n       (else result1 result2 ...))\n     (begin result1 result2 ...))\n    ;; Single clause with => - apply proc to key if match\n    ((case \"dispatch\" key\n       ((atoms ...) => proc))\n     (if (memv key '(atoms ...))\n         (proc key)))\n    ;; => clause with more clauses following\n    ((case \"dispatch\" key\n       ((atoms ...) => proc)\n       clause clauses ...)\n     (if (memv key '(atoms ...))\n         (proc key)\n         (case \"dispatch\" key clause clauses ...)))\n    ;; Single clause with results\n    ((case \"dispatch\" key\n       ((atoms ...) result1 result2 ...))\n     (if (memv key '(atoms ...))\n         (begin result1 result2 ...)))\n    ;; Multiple clauses with results\n    ((case \"dispatch\" key\n       ((atoms ...) result1 result2 ...)\n       clause clauses ...)\n     (if (memv key '(atoms ...))\n         (begin result1 result2 ...)\n         (case \"dispatch\" key clause clauses ...)))\n    ;; No match case\n    ((case \"dispatch\" key)\n     (if #f #t))\n    ;; Entry point - bind key once\n    ((case key\n       clauses ...)\n     (let ((atom-key key))\n       (case \"dispatch\" atom-key clauses ...)))))\n\n;; =============================================================================\n;; Exception Handling\n;; =============================================================================\n\n;; /**\n;;  * Exception handling construct (R7RS).\n;;  * Catches exceptions and dispatches based on condition clauses.\n;;  *\n;;  * @param {symbol} var - Variable to bind to exception.\n;;  * @param {...clause} clauses - Exception handling clauses.\n;;  * @param {...expression} body - Body expressions to protect.\n;;  */\n(define-syntax guard\n  (syntax-rules ()\n    ((guard (var clause ...) body ...)\n     (call/cc\n       (lambda (guard-exit)\n         (with-exception-handler\n           (lambda (condition)\n             (let ((var condition))\n               (guard-clauses guard-exit var clause ...)))\n           (lambda ()\n             body ...)))))))\n\n;; /**\n;;  * Helper macro to process guard clauses.\n;;  * Evaluates clauses in order, re-raising if none match.\n;;  */\n(define-syntax guard-clauses\n  (syntax-rules (else =>)\n    ;; else clause - always matches\n    ((guard-clauses exit var (else result1 result2 ...))\n     (exit (begin result1 result2 ...)))\n    ;; => clause with more clauses following (must come before non-=> versions!)\n    ((guard-clauses exit var (test => proc) clause ...)\n     (let ((temp test))\n       (if temp\n           (exit (proc temp))\n           (guard-clauses exit var clause ...))))\n    ;; => clause - apply proc to result if test is true (single clause)\n    ((guard-clauses exit var (test => proc))\n     (let ((temp test))\n       (if temp\n           (exit (proc temp))\n           (raise var))))\n    ;; test with results and more clauses\n    ((guard-clauses exit var (test result1 result2 ...) clause ...)\n     (if test\n         (exit (begin result1 result2 ...))\n         (guard-clauses exit var clause ...)))\n    ;; test with results - return results if test is true (single clause)\n    ((guard-clauses exit var (test result1 result2 ...))\n     (if test\n         (exit (begin result1 result2 ...))\n         (raise var)))\n    ;; test only with more clauses\n    ((guard-clauses exit var (test) clause ...)\n     (let ((temp test))\n       (if temp\n           (exit temp)\n           (guard-clauses exit var clause ...))))\n    ;; test only - return result of test if true (single clause)\n    ((guard-clauses exit var (test))\n     (let ((temp test))\n       (if temp\n           (exit temp)\n           (raise var))))\n    ;; no clauses matched - re-raise\n    ((guard-clauses exit var)\n     (raise var))))\n",
  "control.sld": "(define-library (scheme control)\n  (import (scheme primitives))\n  (import (scheme core)) ;; for let, if, begin, etc.\n\n  (include \"control.scm\")\n\n  (export\n    when unless or let* do case guard\n    let-values let*-values define-values\n  )\n)\n",
  "core.scm": "; Core Bootstrap Module\n; \n; This file is a container/index for the core Scheme procedures.\n; The actual implementations are split into separate files for organization:\n;\n;   macros.scm     - Core macros: and, let, letrec, cond, define-record-type\n;   equality.scm   - equal? deep equality\n;   cxr.scm        - All 28 car/cdr composition accessors\n;   numbers.scm    - Numeric comparisons, predicates, min/max, gcd/lcm, round\n;   list.scm       - List procedures: map, for-each, memq/v, assq/v, length, etc.\n;\n; The test runner loads these files individually in the correct order.\n; For library-based loading, see base.sld and core.sld.\n;\n; NOTE: This file is kept for documentation purposes and backwards compatibility.\n; If loaded directly, it does nothing because the content is in separate files.\n",
  "core.sld": "(define-library (scheme core)\n  (import (scheme primitives))\n  \n  ;; Include separate Scheme files in dependency order\n  (include \"macros.scm\")     ; Core macros: and, let, letrec, cond\n  (include \"equality.scm\")   ; equal?\n  (include \"cxr.scm\")        ; caar, cadr, etc.\n  (include \"numbers.scm\")    ; =, <, >, predicates, min/max\n  (include \"list.scm\")       ; map, for-each, memq, assq, etc.\n  (include \"parameter.scm\")  ; make-parameter, parameterize\n  \n  (export\n    ;; Macros\n    and or let let* letrec cond\n    define-record-type define-record-field\n    define-class define-class-field define-class-method\n    \n    ;; Deep equality\n    equal?\n    \n    ;; List operations\n    map for-each\n    string-map string-for-each\n    vector-map vector-for-each\n    memq memv member\n    assq assv assoc\n    length list-ref list-tail reverse list-copy\n    make-list list-set!\n    \n    ;; Compound accessors (cxr)\n    caar cadr cdar cddr\n    caaar caadr cadar caddr cdaar cdadr cddar cdddr\n    caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr\n    cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr\n    \n    ;; Comparison operators (variadic)\n    = < > <= >=\n    \n    ;; Numeric predicates\n    zero? positive? negative? odd? even?\n    \n    ;; Min/max\n    max min\n    \n    ;; GCD/LCM\n    gcd lcm\n    \n    ;; Rounding\n    round inexact->exact\n    \n    ;; Parameter objects\n    make-parameter parameterize param-dynamic-bind\n    \n    ;; Misc\n    native-report-test-result\n  )\n)\n\n",
  "cxr.scm": ";; CXR Accessors\n;; All 28 compound car/cdr accessors up to 4 levels deep\n\n;; Depth 2\n(define (caar x) (car (car x)))\n(define (cadr x) (car (cdr x)))\n(define (cdar x) (cdr (car x)))\n(define (cddr x) (cdr (cdr x)))\n\n;; Depth 3\n(define (caaar x) (car (car (car x))))\n(define (caadr x) (car (car (cdr x))))\n(define (cadar x) (car (cdr (car x))))\n(define (caddr x) (car (cdr (cdr x))))\n(define (cdaar x) (cdr (car (car x))))\n(define (cdadr x) (cdr (car (cdr x))))\n(define (cddar x) (cdr (cdr (car x))))\n(define (cdddr x) (cdr (cdr (cdr x))))\n\n;; Depth 4\n(define (caaaar x) (car (car (car (car x)))))\n(define (caaadr x) (car (car (car (cdr x)))))\n(define (caadar x) (car (car (cdr (car x)))))\n(define (caaddr x) (car (car (cdr (cdr x)))))\n(define (cadaar x) (car (cdr (car (car x)))))\n(define (cadadr x) (car (cdr (car (cdr x)))))\n(define (caddar x) (car (cdr (cdr (car x)))))\n(define (cadddr x) (car (cdr (cdr (cdr x)))))\n(define (cdaaar x) (cdr (car (car (car x)))))\n(define (cdaadr x) (cdr (car (car (cdr x)))))\n(define (cdadar x) (cdr (car (cdr (car x)))))\n(define (cdaddr x) (cdr (car (cdr (cdr x)))))\n(define (cddaar x) (cdr (cdr (car (car x)))))\n(define (cddadr x) (cdr (cdr (car (cdr x)))))\n(define (cdddar x) (cdr (cdr (cdr (car x)))))\n(define (cddddr x) (cdr (cdr (cdr (cdr x)))))\n",
  "cxr.sld": ";; R7RS (scheme cxr) library\n;; \n;; Provides compound car/cdr accessors up to 4 levels deep.\n;; Per R7RS Appendix A.\n\n(define-library (scheme cxr)\n  (import (scheme core))\n\n  (export\n    ;; Depth 2\n    caar cadr cdar cddr\n    \n    ;; Depth 3\n    caaar caadr cadar caddr\n    cdaar cdadr cddar cdddr\n    \n    ;; Depth 4\n    caaaar caaadr caadar caaddr\n    cadaar cadadr caddar cadddr\n    cdaaar cdaadr cdadar cdaddr\n    cddaar cddadr cdddar cddddr\n  )\n)\n",
  "equality.scm": ";; Equality Procedures\n;; Structural equality testing\n\n;; /**\n;;  * Deep equality check.\n;;  * Recursively compares pairs and vectors. Uses eqv? for other types.\n;;  *\n;;  * @param {*} a - First object.\n;;  * @param {*} b - Second object.\n;;  * @returns {boolean} #t if objects are structurally equal, #f otherwise.\n;;  */\n(define (equal? a b)\n  (cond\n    ((eqv? a b) #t)\n    ((and (pair? a) (pair? b))\n     (and (equal? (car a) (car b))\n          (equal? (cdr a) (cdr b))))\n    ((and (vector? a) (vector? b))\n     (let ((len-a (vector-length a))\n           (len-b (vector-length b)))\n       (if (= len-a len-b)\n           (let loop ((i 0))\n             (if (= i len-a)\n                 #t\n                 (if (equal? (vector-ref a i) (vector-ref b i))\n                     (loop (+ i 1))\n                     #f)))\n           #f)))\n    ((and (bytevector? a) (bytevector? b))\n     (let ((len-a (bytevector-length a))\n           (len-b (bytevector-length b)))\n       (if (= len-a len-b)\n           (let loop ((i 0))\n             (if (= i len-a)\n                 #t\n                 (if (= (bytevector-u8-ref a i) (bytevector-u8-ref b i))\n                     (loop (+ i 1))\n                     #f)))\n           #f)))\n    ((and (string? a) (string? b))\n     (eqv? a b)) ; Strings are primitives in JS, so eqv? (Object.is) works. \n    (else #f)))\n",
  "eval.sld": ";; (scheme eval) library\n;;\n;; R7RS evaluation procedures.\n;; Note: environment procedure not fully supported - returns interaction environment.\n\n(define-library (scheme eval)\n  (import (scheme base))\n  (export eval environment)\n  (begin\n    ;; eval and interaction-environment are already primitives\n    ;; environment returns the interaction-environment for now\n    ;; (R7RS allows implementation-defined behavior for environment)\n    (define (environment . import-specs)\n      (interaction-environment))))\n",
  "file.sld": ";; R7RS (scheme file) library\n;;\n;; Provides file I/O operations (Node.js only).\n;; Per R7RS ยง6.13.\n\n(define-library (scheme file)\n  (import (scheme primitives))\n  \n  (export\n    open-input-file\n    open-output-file\n    call-with-input-file\n    call-with-output-file\n    file-exists?\n    delete-file\n  )\n  \n  (begin\n    ;; All procedures are implemented as primitives\n    ;; Note: These procedures only work in Node.js\n    ;; Browser calls will raise errors\n  ))\n",
  "lazy.scm": ";; (scheme lazy) library\n;;\n;; R7RS lazy evaluation (delay/force) implementation.\n;;\n;; A promise is a pair: (forced? . value-or-thunk)\n;; - When not forced: (#f . thunk)\n;; - When forced: (#t . value)\n\n;; /**\n;;  * promise? - Check if an object is a promise.\n;;  * @param {*} obj - Object to check.\n;;  * @returns {boolean} True if obj is a promise.\n;;  */\n(define (promise? obj)\n  (and (pair? obj)\n       (pair? (car obj))\n       (eq? (caar obj) 'promise-tag)))\n\n;; Internal promise constructor\n(define (make-promise-internal thunk)\n  (cons (cons 'promise-tag #f) thunk))\n\n;; /**\n;;  * make-promise - Wrap a value in an already-forced promise.\n;;  * @param {*} obj - Value to wrap.\n;;  * @returns {promise} A promise that yields obj.\n;;  */\n(define (make-promise obj)\n  (if (promise? obj)\n      obj\n      (cons (cons 'promise-tag #t) obj)))\n\n;; /**\n;;  * force - Force a promise and return its value.\n;;  * @param {promise} promise - The promise to force.\n;;  * @returns {*} The forced value.\n;;  */\n(define (force promise)\n  (if (not (promise? promise))\n      (error \"force: expected promise\" promise))\n  (if (cdar promise)  ; already forced?\n      (cdr promise)   ; return cached value\n      (let ((result ((cdr promise))))  ; call thunk\n        (if (cdar promise)  ; check again (thunk may have forced recursively)\n            (cdr promise)\n            (begin\n              (set-cdr! (car promise) #t)  ; mark as forced\n              (set-cdr! promise result)     ; cache value\n              result)))))\n",
  "lazy.sld": ";; (scheme lazy) library\n;;\n;; R7RS lazy evaluation procedures.\n\n(define-library (scheme lazy)\n  (import (scheme base))\n  (export delay force make-promise promise? delay-force)\n  (include \"lazy.scm\")\n  (begin\n    ;; /**\n    ;;  * delay - Create a promise that will evaluate expr when forced.\n    ;;  * @syntax (delay expr)\n    ;;  * @returns {promise} A promise.\n    ;;  */\n    ;; Note: Inline promise construction to avoid hygiene issues with internal binding\n    (define-syntax delay\n      (syntax-rules ()\n        ((delay expr)\n         (cons (cons 'promise-tag #f) (lambda () expr)))))\n    \n    ;; /**\n    ;;  * delay-force - Create a promise that forces another promise when forced.\n    ;;  * Used for iterative lazy algorithms.\n    ;;  * @syntax (delay-force expr)\n    ;;  * @returns {promise} A promise.\n    ;;  */\n    (define-syntax delay-force\n      (syntax-rules ()\n        ((delay-force expr)\n         (cons (cons 'promise-tag #f) (lambda () (force expr))))))))\n\n",
  "list.scm": ";; List Procedures\n;; Higher-order list operations and searching\n\n;; /**\n;;  * Native hook for reporting test results.\n;;  * This is intended to be overridden by the environment (Node/Browser) if needed,\n;;  * or used by the test harness to communicate results to the host.\n;;  *\n;;  * @param {...*} args - Test result arguments.\n;;  * @returns {boolean} #f (default implementation).\n;;  */\n(define (native-report-test-result . args) #f)\n\n;; /**\n;;  * Applies a function to corresponding elements of one or more lists.\n;;  * Returns a new list of results. When multiple lists are given,\n;;  * the result is the same length as the shortest list (R7RS).\n;;  * Supports circular lists when used with multiple lists (stops at shortest).\n;;\n;;  * @param {procedure} proc - The function to apply.\n;;  * @param {list} lst - First list.\n;;  * @param {...list} lsts - Additional lists (optional).\n;;  * @returns {list} A new list containing the results.\n;;  */\n(define (map proc lst . lsts)\n  (if (not (procedure? proc))\n      (error \"map: expected procedure\" proc))\n  ;; For proper error messages, check that first arg is a list or null\n  ;; But for circular list support, we only check pair-ness during iteration\n  (if (and (not (null? lst)) (not (pair? lst)))\n      (error \"map: expected list\" lst))\n  (if (null? lsts)\n      ;; Single list case - works with proper lists\n      ;; (circular single list would loop forever - that's expected behavior)\n      (letrec ((loop (lambda (l)\n                       (if (null? l)\n                           '()\n                           (cons (proc (car l))\n                                 (loop (cdr l)))))))\n        (loop lst))\n      ;; Multiple lists case - stop at shortest (works with circular lists)\n      (begin\n        (for-each (lambda (l)\n                    (if (and (not (null? l)) (not (pair? l)))\n                        (error \"map: expected list\" l)))\n                  lsts)\n        (letrec ((any-null? (lambda (lists)\n                              (if (null? lists)\n                                  #f\n                                  (or (null? (car lists))\n                                      (any-null? (cdr lists))))))\n                 (all-cars (lambda (lists)\n                             (if (null? lists)\n                                 '()\n                                 (cons (caar lists) (all-cars (cdr lists))))))\n                 (all-cdrs (lambda (lists)\n                             (if (null? lists)\n                                 '()\n                                 (cons (cdar lists) (all-cdrs (cdr lists))))))\n                 (loop (lambda (first-list rest-lists)\n                         (if (or (null? first-list) (any-null? rest-lists))\n                             '()\n                             (cons (apply proc (cons (car first-list) (all-cars rest-lists)))\n                                   (loop (cdr first-list) (all-cdrs rest-lists)))))))\n          (loop lst lsts)))))\n\n;; /**\n;;  * Applies a procedure to each element of one or more lists for side effects.\n;;  * When multiple lists are given, iterates until the shortest is exhausted (R7RS).\n;;  * Supports circular lists when used with multiple lists.\n;;\n;;  * @param {procedure} proc - The procedure to apply.\n;;  * @param {list} lst - First list.\n;;  * @param {...list} lsts - Additional lists (optional).\n;;  * @returns {undefined} Unspecified.\n;;  */\n(define (for-each proc lst . lsts)\n  (if (not (procedure? proc))\n      (error \"for-each: expected procedure\" proc))\n  ;; Check first arg - allow circular lists (pair? but not list?)\n  (if (and (not (null? lst)) (not (pair? lst)))\n      (error \"for-each: expected list\" lst))\n  (if (null? lsts)\n      ;; Single list case\n      (letrec ((loop (lambda (l)\n                       (if (not (null? l))\n                           (begin\n                             (proc (car l))\n                             (loop (cdr l)))))))\n        (loop lst))\n      ;; Multiple lists case - stop at shortest (works with circular lists)\n      (letrec ((any-null? (lambda (lists)\n                            (if (null? lists)\n                                #f\n                                (or (null? (car lists))\n                                    (any-null? (cdr lists))))))\n               (all-cars (lambda (lists)\n                           (if (null? lists)\n                               '()\n                               (cons (caar lists) (all-cars (cdr lists))))))\n               (all-cdrs (lambda (lists)\n                           (if (null? lists)\n                               '()\n                               (cons (cdar lists) (all-cdrs (cdr lists))))))\n               (loop (lambda (first-list rest-lists)\n                       (if (not (or (null? first-list) (any-null? rest-lists)))\n                           (begin\n                             (apply proc (cons (car first-list) (all-cars rest-lists)))\n                             (loop (cdr first-list) (all-cdrs rest-lists)))))))\n        (loop lst lsts))))\n\n;; /**\n;;  * Applies a procedure to corresponding characters of strings.\n;;  * Returns a new string of the results. When multiple strings are given,\n;;  * the result length is the same as the shortest string (R7RS).\n;;\n;;  * @param {procedure} proc - The procedure to apply.\n;;  * @param {string} str - First string.\n;;  * @param {...string} strs - Additional strings (optional).\n;;  * @returns {string} A new string of the results.\n;;  */\n(define (string-map proc str . strs)\n  (if (not (procedure? proc))\n      (error \"string-map: expected procedure\" proc))\n  (if (not (string? str))\n      (error \"string-map: expected string\" str))\n  ;; Calculate minimum length across all strings\n  (let ((len (let loop ((min-len (string-length str)) (ss strs))\n               (if (null? ss)\n                   min-len\n                   (begin\n                     (if (not (string? (car ss)))\n                         (error \"string-map: expected string\" (car ss)))\n                     (loop (min min-len (string-length (car ss))) (cdr ss)))))))\n    (if (null? strs)\n        ;; Single string case\n        (list->string\n         (letrec ((loop (lambda (i acc)\n                          (if (< i 0)\n                              acc\n                              (loop (- i 1) (cons (proc (string-ref str i)) acc))))))\n           (loop (- len 1) '())))\n        ;; Multiple strings case\n        (list->string\n         (letrec ((loop (lambda (i acc)\n                          (if (< i 0)\n                              acc\n                              (let ((chars (cons (string-ref str i)\n                                                 (map (lambda (s) (string-ref s i)) strs))))\n                                (loop (- i 1) (cons (apply proc chars) acc)))))))\n           (loop (- len 1) '()))))))\n\n;; /**\n;;  * Applies a procedure to corresponding characters of strings for side effects.\n;;\n;;  * @param {procedure} proc - The procedure to apply.\n;;  * @param {string} str - First string.\n;;  * @param {...string} strs - Additional strings (optional).\n;;  * @returns {undefined} Unspecified.\n;;  */\n(define (string-for-each proc str . strs)\n  (if (not (procedure? proc))\n      (error \"string-for-each: expected procedure\" proc))\n  (if (not (string? str))\n      (error \"string-for-each: expected string\" str))\n  (let ((len (string-length str)))\n    (for-each (lambda (s)\n                (if (not (string? s))\n                    (error \"string-for-each: expected string\" s))\n                (if (not (= (string-length s) len))\n                    (error \"string-for-each: strings must have same length\")))\n              strs)\n    (if (null? strs)\n        ;; Single string case\n        (letrec ((loop (lambda (i)\n                         (if (< i len)\n                             (begin\n                               (proc (string-ref str i))\n                               (loop (+ i 1)))))))\n          (loop 0))\n        ;; Multiple strings case\n        (letrec ((loop (lambda (i)\n                         (if (< i len)\n                             (let ((chars (cons (string-ref str i)\n                                                (map (lambda (s) (string-ref s i)) strs))))\n                               (apply proc chars)\n                               (loop (+ i 1)))))))\n          (loop 0)))))\n\n;; /**\n;;  * Applies a procedure to corresponding elements of vectors.\n;;  * Returns a new vector of the results. When multiple vectors are given,\n;;  * the result length is the same as the shortest vector (R7RS).\n;;\n;;  * @param {procedure} proc - The procedure to apply.\n;;  * @param {vector} vec - First vector.\n;;  * @param {...vector} vecs - Additional vectors (optional).\n;;  * @returns {vector} A new vector of the results.\n;;  */\n(define (vector-map proc vec . vecs)\n  (if (not (procedure? proc))\n      (error \"vector-map: expected procedure\" proc))\n  (if (not (vector? vec))\n      (error \"vector-map: expected vector\" vec))\n  ;; Calculate minimum length across all vectors\n  (let ((len (let loop ((min-len (vector-length vec)) (vs vecs))\n               (if (null? vs)\n                   min-len\n                   (begin\n                     (if (not (vector? (car vs)))\n                         (error \"vector-map: expected vector\" (car vs)))\n                     (loop (min min-len (vector-length (car vs))) (cdr vs)))))))\n    (if (null? vecs)\n        ;; Single vector case\n        (let ((result (make-vector len)))\n          (letrec ((loop (lambda (i)\n                           (if (< i len)\n                               (begin\n                                 (vector-set! result i (proc (vector-ref vec i)))\n                                 (loop (+ i 1)))))))\n            (loop 0))\n          result)\n        ;; Multiple vectors case\n        (let ((result (make-vector len)))\n          (letrec ((loop (lambda (i)\n                           (if (< i len)\n                               (let ((elems (cons (vector-ref vec i)\n                                                  (map (lambda (v) (vector-ref v i)) vecs))))\n                                 (vector-set! result i (apply proc elems))\n                                 (loop (+ i 1)))))))\n            (loop 0))\n          result))))\n\n;; /**\n;;  * Applies a procedure to corresponding elements of vectors for side effects.\n;;\n;;  * @param {procedure} proc - The procedure to apply.\n;;  * @param {vector} vec - First vector.\n;;  * @param {...vector} vecs - Additional vectors (optional).\n;;  * @returns {undefined} Unspecified.\n;;  */\n(define (vector-for-each proc vec . vecs)\n  (if (not (procedure? proc))\n      (error \"vector-for-each: expected procedure\" proc))\n  (if (not (vector? vec))\n      (error \"vector-for-each: expected vector\" vec))\n  (let ((len (vector-length vec)))\n    (for-each (lambda (v)\n                (if (not (vector? v))\n                    (error \"vector-for-each: expected vector\" v))\n                (if (not (= (vector-length v) len))\n                    (error \"vector-for-each: vectors must have same length\")))\n              vecs)\n    (if (null? vecs)\n        ;; Single vector case\n        (letrec ((loop (lambda (i)\n                         (if (< i len)\n                             (begin\n                               (proc (vector-ref vec i))\n                               (loop (+ i 1)))))))\n          (loop 0))\n        ;; Multiple vectors case\n        (letrec ((loop (lambda (i)\n                         (if (< i len)\n                             (let ((elems (cons (vector-ref vec i)\n                                                (map (lambda (v) (vector-ref v i)) vecs))))\n                               (apply proc elems)\n                               (loop (+ i 1)))))))\n          (loop 0)))))\n\n;; =============================================================================\n;; Membership Procedures\n;; =============================================================================\n\n;; /**\n;;  * Return the sublist of list whose car is eq? to obj.\n;;  * Return #f if obj is not found.\n;;\n;;  * @param {any} obj - Object to find.\n;;  * @param {list} lst - List to search.\n;;  * @return {list|boolean} Sublist or #f.\n;;  */\n(define (memq obj lst)\n  (if (not (list? lst))\n      (error \"memq: expected list\" lst))\n  (letrec ((loop (lambda (l)\n                   (if (null? l)\n                       #f\n                       (if (eq? obj (car l))\n                           l\n                           (loop (cdr l)))))))\n    (loop lst)))\n\n;; /**\n;;  * Return the sublist of list whose car is eqv? to obj.\n;;  * Return #f if obj is not found.\n;;\n;;  * @param {any} obj - Object to find.\n;;  * @param {list} lst - List to search.\n;;  * @return {list|boolean} Sublist or #f.\n;;  */\n(define (memv obj lst)\n  (if (not (list? lst))\n      (error \"memv: expected list\" lst))\n  (letrec ((loop (lambda (l)\n                   (if (null? l)\n                       #f\n                       (if (eqv? obj (car l))\n                           l\n                           (loop (cdr l)))))))\n    (loop lst)))\n\n;; /**\n;;  * Return the sublist of list whose car is equal? to obj.\n;;  * Return #f if obj is not found.\n;;  * Optionally takes a custom comparison procedure.\n;;\n;;  * @param {any} obj - Object to find.\n;;  * @param {list} lst - List to search.\n;;  * @param {procedure} [compare] - Optional comparison procedure (default equal?).\n;;  * @return {list|boolean} Sublist or #f.\n;;  */\n(define (member obj lst . compare)\n  (if (not (list? lst))\n      (error \"member: expected list\" lst))\n  (let ((cmp (if (null? compare) equal? (car compare))))\n    (letrec ((loop (lambda (l)\n                     (if (null? l)\n                         #f\n                         (if (cmp obj (car l))\n                             l\n                             (loop (cdr l)))))))\n      (loop lst))))\n\n;; =============================================================================\n;; Association List Procedures\n;; =============================================================================\n\n;; /**\n;;  * Return the first element of alist whose car is eq? to obj.\n;;  * Return #f if not found.\n;;\n;;  * @param {any} obj - Key to find.\n;;  * @param {list} alist - Association list to search.\n;;  * @return {pair|boolean} Association pair or #f.\n;;  */\n(define (assq obj alist)\n  (if (not (list? alist))\n      (error \"assq: expected list\" alist))\n  (letrec ((loop (lambda (l)\n                   (if (null? l)\n                       #f\n                       (let ((pair (car l)))\n                         (if (not (pair? pair))\n                             (error \"assq: expected pair in alist\" pair))\n                         (if (eq? obj (car pair))\n                             pair\n                             (loop (cdr l))))))))\n    (loop alist)))\n\n;; /**\n;;  * Return the first element of alist whose car is eqv? to obj.\n;;  * Return #f if not found.\n;;\n;;  * @param {any} obj - Key to find.\n;;  * @param {list} alist - Association list to search.\n;;  * @return {pair|boolean} Association pair or #f.\n;;  */\n(define (assv obj alist)\n  (if (not (list? alist))\n      (error \"assv: expected list\" alist))\n  (letrec ((loop (lambda (l)\n                   (if (null? l)\n                       #f\n                       (let ((pair (car l)))\n                         (if (not (pair? pair))\n                             (error \"assv: expected pair in alist\" pair))\n                         (if (eqv? obj (car pair))\n                             pair\n                             (loop (cdr l))))))))\n    (loop alist)))\n\n;; /**\n;;  * Return the first element of alist whose car is equal? to obj.\n;;  * Return #f if not found. Optionally takes a custom comparison procedure.\n;;\n;;  * @param {any} obj - Key to find.\n;;  * @param {list} alist - Association list to search.\n;;  * @param {procedure} [compare] - Optional comparison procedure (default equal?).\n;;  * @return {pair|boolean} Association pair or #f.\n;;  */\n(define (assoc obj alist . compare)\n  (if (not (list? alist))\n      (error \"assoc: expected list\" alist))\n  (let ((cmp (if (null? compare) equal? (car compare))))\n    (letrec ((loop (lambda (l)\n                     (if (null? l)\n                         #f\n                         (let ((pair (car l)))\n                           (if (not (pair? pair))\n                               (error \"assoc: expected pair in alist\" pair))\n                           (if (cmp obj (car pair))\n                               pair\n                               (loop (cdr l))))))))\n      (loop alist))))\n\n;; =============================================================================\n;; List Accessors and Utilities\n;; =============================================================================\n\n;; /**\n;;  * Returns the length of a proper list.\n;;\n;;  * @param {list} lst - A proper list.\n;;  * @returns {integer} Length of the list.\n;;  */\n(define (length lst)\n  (if (not (list? lst))\n      (error \"length: expected list\" lst))\n  (letrec ((loop (lambda (l count)\n                   (if (null? l)\n                       count\n                       (loop (cdr l) (+ count 1))))))\n    (loop lst 0)))\n\n;; /**\n;;  * Returns the kth element of a list (0-indexed).\n;;\n;;  * @param {pair} lst - A list.\n;;  * @param {integer} k - Index.\n;;  * @returns {*} The kth element.\n;;  */\n(define (list-ref lst k)\n  (if (not (pair? lst))\n      (error \"list-ref: expected pair\" lst))\n  (if (not (integer? k))\n      (error \"list-ref: expected exact integer\" k))\n  (if (< k 0)\n      (error \"list-ref: index out of range\" k))\n  (letrec ((loop (lambda (l i)\n                   (cond\n                     ((null? l) (error \"list-ref: index out of range\" k))\n                     ((not (pair? l)) (error \"list-ref: improper list\" l))\n                     ((= i 0) (car l))\n                     (else (loop (cdr l) (- i 1)))))))\n    (loop lst k)))\n\n;; /**\n;;  * Returns the sublist starting at index k.\n;;\n;;  * @param {list} lst - A list.\n;;  * @param {integer} k - Index.\n;;  * @returns {list} The sublist.\n;;  */\n(define (list-tail lst k)\n  (if (not (integer? k))\n      (error \"list-tail: expected exact integer\" k))\n  (if (< k 0)\n      (error \"list-tail: index out of range\" k))\n  (letrec ((loop (lambda (l i)\n                   (cond\n                     ((= i 0) l)\n                     ((null? l) (error \"list-tail: index out of range\" k))\n                     ((not (pair? l)) (error \"list-tail: improper list\" l))\n                     (else (loop (cdr l) (- i 1)))))))\n    (loop lst k)))\n\n;; /**\n;;  * Reverses a proper list.\n;;\n;;  * @param {list} lst - A proper list.\n;;  * @returns {list} Reversed list.\n;;  */\n(define (reverse lst)\n  (if (not (list? lst))\n      (error \"reverse: expected list\" lst))\n  (letrec ((loop (lambda (l result)\n                   (if (null? l)\n                       result\n                       (loop (cdr l) (cons (car l) result))))))\n    (loop lst '())))\n\n;; /**\n;;  * Creates a shallow copy of a list.\n;;\n;;  * @param {*} obj - An object (if pair, copies structure).\n;;  * @returns {*} Copy of the object.\n;;  */\n(define (list-copy obj)\n  (if (not (pair? obj))\n      obj\n      (cons (car obj) (list-copy (cdr obj)))))\n\n;; /**\n;;  * Creates a list of k elements, each initialized to fill (default is #f).\n;;\n;;  * @param {integer} k - The number of elements.\n;;  * @param {*} fill - The value to fill (optional, default #f).\n;;  * @returns {list} A new list of k elements.\n;;  */\n(define (make-list k . rest)\n  (if (not (integer? k))\n      (error \"make-list: expected integer\" k))\n  (if (< k 0)\n      (error \"make-list: expected non-negative integer\" k))\n  (let ((fill (if (null? rest) #f (car rest))))\n    (letrec ((loop (lambda (n)\n                     (if (= n 0)\n                         '()\n                         (cons fill (loop (- n 1)))))))\n      (loop k))))\n\n;; /**\n;;  * Stores obj in element k of list.\n;;  * It is an error if k is not a valid index of list.\n;;\n;;  * @param {list} lst - A proper list.\n;;  * @param {integer} k - The index.\n;;  * @param {*} obj - The value to store.\n;;  * @returns {unspecified}\n;;  */\n(define (list-set! lst k obj)\n  (if (not (list? lst))\n      (error \"list-set!: expected list\" lst))\n  (if (not (integer? k))\n      (error \"list-set!: expected integer index\" k))\n  (if (or (< k 0) (>= k (length lst)))\n      (error \"list-set!: index out of range\" k))\n  (if (= k 0)\n      (set-car! lst obj)\n      (list-set! (cdr lst) (- k 1) obj)))\n\n",
  "macros.scm": ";; Core Macros\n;; Fundamental macros for bootstrapping\n\n;; /**\n;;  * Logical AND macro.\n;;  * Short-circuits evaluation: returns #f immediately if any expression evaluates to #f.\n;;  * Returns the value of the last expression if all are true.\n;;  *\n;;  * @param {boolean} ...test - Expressions to evaluate.\n;;  * @returns {boolean|*} #f if any test is false, otherwise the value of the last test.\n;;  */\n(define-syntax and\n  (syntax-rules ()\n    ((and) #t)\n    ((and test) test)\n    ((and test1 test2 ...)\n     (if test1 (and test2 ...) #f))))\n\n;; /**\n;;  * Logical OR macro.\n;;  * Short-circuits evaluation: returns the first true value, or #f if all are false.\n;;  *\n;;  * @param {boolean} ...test - Expressions to evaluate.\n;;  * @returns {boolean|*} First true value, or #f.\n;;  */\n(define-syntax or\n  (syntax-rules ()\n    ((or) #f)\n    ((or test) test)\n    ((or test1 test2 ...)\n     (let ((x test1))\n       (if x x (or test2 ...))))))\n\n;; /**\n;;  * Sequential binding macro.\n;;  * Binds variables sequentially, allowing later bindings to refer to earlier ones.\n;;  *\n;;  * @param {list} bindings - List of ((variable init) ...) bindings.\n;;  * @param {...expression} body - Body to evaluate.\n;;  */\n(define-syntax let*\n  (syntax-rules ()\n    ((let* () body1 body2 ...)\n     (let () body1 body2 ...))\n    ((let* ((name1 val1) (name2 val2) ...) body1 body2 ...)\n     (let ((name1 val1))\n       (let* ((name2 val2) ...)\n         body1 body2 ...)))))\n\n;; /**\n;;  * Binds variables to values within a scope.\n;;  * Supports both standard let (parallel binding) and named let (for recursion).\n;;  *\n;;  * @param {symbol|list} tag_or_bindings - Either a name for the loop (named let) or the list of bindings.\n;;  * @param {list} [bindings] - List of ((name val) ...) bindings (if named let).\n;;  * @param {...*} body - Body expressions to evaluate.\n;;  * @returns {*} Result of the last expression in the body.\n;;  */\n(define-syntax let\n  (syntax-rules ()\n    ((let ((name val) ...) body1 body2 ...)\n     ((lambda (name ...) body1 body2 ...) val ...))\n    ((let tag ((name val) ...) body1 body2 ...)\n     ((letrec ((tag (lambda (name ...) body1 body2 ...)))\n        tag)\n      val ...))))\n\n;; /**\n;;  * Recursive binding construct.\n;;  * Allows defining mutually recursive functions.\n;;  *\n;;  * @param {list} bindings - List of ((var init) ...) bindings.\n;;  * @param {...*} body - Body expressions to evaluate.\n;;  * @returns {*} Result of the last expression in the body.\n;;  */\n(define-syntax letrec\n  (syntax-rules ()\n    ((letrec ((var init) ...) body ...)\n     (let ((var 'undefined) ...)\n       (set! var init) ...\n       (let () body ...)))))\n\n;; /**\n;;  * Sequential recursive binding construct.\n;;  * Like letrec but guarantees left-to-right evaluation of inits.\n;;  *\n;;  * @param {list} bindings - List of ((var init) ...) bindings.\n;;  * @param {...*} body - Body expressions to evaluate.\n;;  * @returns {*} Result of the last expression in the body.\n;;  */\n(define-syntax letrec*\n  (syntax-rules ()\n    ;; Empty case\n    ((letrec* () body ...)\n     (let () body ...))\n    ;; Use a helper to collect bindings, then expand\n    ((letrec* ((var init) ...) body ...)\n     (let ((var 'undefined) ...)\n       (letrec* \"init\" ((var init) ...) body ...)))\n    ;; Helper: initialize each binding sequentially, then run body\n    ((letrec* \"init\" () body ...)\n     (let () body ...))\n    ((letrec* \"init\" ((var init) rest ...) body ...)\n     (begin\n       (set! var init)\n       (letrec* \"init\" (rest ...) body ...)))))\n\n;; /**\n;;  * Conditional expression.\n;;  * Evaluates clauses sequentially until one's test evaluates to true.\n;;  *\n;;  * @param {...list} clauses - List of (test expression...) clauses.\n;;  * @returns {*} Result of the evaluated clause, or undefined if no else clause matches.\n;;  */\n(define-syntax cond\n  (syntax-rules (else =>)\n    ((cond (else result1 result2 ...))\n     (begin result1 result2 ...))\n    ((cond (test => result))\n     (let ((temp test))\n       (if temp (result temp))))\n    ((cond (test => result) clause1 clause2 ...)\n     (let ((temp test))\n       (if temp\n           (result temp)\n           (cond clause1 clause2 ...))))\n    ((cond (test)) test)\n    ((cond (test) clause1 clause2 ...)\n     (let ((temp test))\n       (if temp\n           temp\n           (cond clause1 clause2 ...))))\n    ((cond (test result1 result2 ...))\n     (if test (begin result1 result2 ...)))\n    ((cond (test result1 result2 ...) clause1 clause2 ...)\n     (if test\n         (begin result1 result2 ...)\n         (cond clause1 clause2 ...)))))\n\n;; /**\n;;  * Internal helper for defining record fields.\n;;  * Defines accessors and modifiers for a specific field of a record type.\n;;  *\n;;  * @param {symbol} type - The record type name.\n;;  * @param {symbol} field-tag - The field name.\n;;  * @param {symbol} accessor - The name of the accessor function.\n;;  * @param {symbol} [modifier] - The name of the modifier function (optional).\n;;  */\n(define-syntax define-record-field\n  (syntax-rules ()\n    ((define-record-field type field-tag accessor)\n     (define accessor (record-accessor type 'field-tag)))\n    ((define-record-field type field-tag accessor modifier)\n     (begin\n       (define accessor (record-accessor type 'field-tag))\n       (define modifier (record-modifier type 'field-tag))))))\n\n;; /**\n;;  * Defines a new record type.\n;;  * Creates a constructor, a type predicate, and accessors/modifiers for fields.\n;;  *\n;;  * @param {symbol} type - The name of the new record type.\n;;  * @param {list} constructor - (constructor tag ...) specification.\n;;  * @param {symbol} predicate - Name for the type predicate (e.g. my-type?).\n;;  * @param {...list} fields - Field specifications (tag accessor [modifier]).\n;;  */\n(define-syntax define-record-type\n  (syntax-rules ()\n    ((define-record-type type\n       (constructor constructor-tag ...)\n       predicate\n       (field-tag accessor . more) ...)\n     (begin\n       (define type (make-record-type 'type '(field-tag ...)))\n       (define constructor (record-constructor type))\n       (define predicate (record-predicate type))\n       (define-record-field type field-tag accessor . more) ...))))\n\n;; /**\n;;  * Internal helper for defining class fields.\n;;  */\n(define-syntax define-class-field\n  (syntax-rules ()\n    ((define-class-field type field-tag accessor)\n     (define accessor (record-accessor type 'field-tag)))\n    ((define-class-field type field-tag accessor modifier)\n     (begin\n       (define accessor (record-accessor type 'field-tag))\n       (define modifier (record-modifier type 'field-tag))))))\n\n;; /**\n;;  * Internal helper for defining class methods.\n;;  */\n(define-syntax define-class-method\n  (syntax-rules ()\n    ((define-class-method type (name (param ...) body ...))\n     (class-method-set! type 'name (lambda (param ...) body ...)))))\n\n;; /**\n;;  * Defines a new JS-compatible class.\n;;  * Creates a constructor, a type predicate, accessors/modifiers for fields,\n;;  * and methods on the class prototype.\n;;  *\n;;  * Syntax:\n;;  * (define-class type [parent]\n;;  *   (constructor constructor-tag ...)\n;;  *   predicate\n;;  *   (fields (field-tag accessor [modifier]) ...)\n;;  *   (methods (method-name (params ...) body ...) ...))\n;;  */\n(define-syntax define-class\n  (syntax-rules (fields methods)\n    ;; Form with parent class\n    ((define-class type parent\n       (constructor-name field-tag ...)\n       predicate\n       (fields (field-tag-spec accessor . more) ...)\n       (methods (method-name params . body) ...))\n     (begin\n       (define type (make-class 'type parent '(field-tag-spec ...) '(field-tag ...)))\n       (define constructor-name (record-constructor type))\n       (define predicate (record-predicate type))\n       (define-class-field type field-tag-spec accessor . more) ...\n       (define-class-method type (method-name params . body)) ...))\n    ;; Form without parent class\n    ((define-class type\n       (constructor-name field-tag ...)\n       predicate\n       (fields (field-tag-spec accessor . more) ...)\n       (methods (method-name params . body) ...))\n     (begin\n       (define type (make-class 'type #f '(field-tag-spec ...) '(field-tag ...)))\n       (define constructor-name (record-constructor type))\n       (define predicate (record-predicate type))\n       (define-class-field type field-tag-spec accessor . more) ...\n       (define-class-method type (method-name params . body)) ...))))\n",
  "numbers.scm": ";; Numeric Procedures\n;; Comparison operators, predicates, and mathematical functions\n\n;; =============================================================================\n;; Variadic Comparison Operators\n;; =============================================================================\n;; These build on the binary primitives (%num=, %num<, etc.) from JavaScript.\n\n;; /**\n;;  * Numeric equality. Returns #t if all arguments are equal.\n;;\n;;  * @param {number} x - First number.\n;;  * @param {number} y - Second number.\n;;  * @param {...number} rest - Additional numbers.\n;;  * @returns {boolean} #t if all are equal.\n;;  */\n(define (= x y . rest)\n  (if (not (%num= x y))\n      #f\n      (if (null? rest)\n          #t\n          (apply = y rest))))\n\n;; /**\n;;  * Less than. Returns #t if arguments are strictly increasing.\n;;\n;;  * @param {number} x - First number.\n;;  * @param {number} y - Second number.\n;;  * @param {...number} rest - Additional numbers.\n;;  * @returns {boolean} #t if strictly increasing.\n;;  */\n(define (< x y . rest)\n  (if (not (%num< x y))\n      #f\n      (if (null? rest)\n          #t\n          (apply < y rest))))\n\n;; /**\n;;  * Greater than. Returns #t if arguments are strictly decreasing.\n;;\n;;  * @param {number} x - First number.\n;;  * @param {number} y - Second number.\n;;  * @param {...number} rest - Additional numbers.\n;;  * @returns {boolean} #t if strictly decreasing.\n;;  */\n(define (> x y . rest)\n  (if (not (%num> x y))\n      #f\n      (if (null? rest)\n          #t\n          (apply > y rest))))\n\n;; /**\n;;  * Less than or equal. Returns #t if arguments are non-decreasing.\n;;\n;;  * @param {number} x - First number.\n;;  * @param {number} y - Second number.\n;;  * @param {...number} rest - Additional numbers.\n;;  * @returns {boolean} #t if non-decreasing.\n;;  */\n(define (<= x y . rest)\n  (if (not (%num<= x y))\n      #f\n      (if (null? rest)\n          #t\n          (apply <= y rest))))\n\n;; /**\n;;  * Greater than or equal. Returns #t if arguments are non-increasing.\n;;\n;;  * @param {number} x - First number.\n;;  * @param {number} y - Second number.\n;;  * @param {...number} rest - Additional numbers.\n;;  * @returns {boolean} #t if non-increasing.\n;;  */\n(define (>= x y . rest)\n  (if (not (%num>= x y))\n      #f\n      (if (null? rest)\n          #t\n          (apply >= y rest))))\n\n;; =============================================================================\n;; Numeric Predicates\n;; =============================================================================\n\n;; /**\n;;  * Zero predicate.\n;;\n;;  * @param {number} x - Number to check.\n;;  * @returns {boolean} #t if x is zero.\n;;  */\n(define (zero? x)\n  (if (not (number? x))\n      (error \"zero?: expected number\" x))\n  (= x 0))\n\n;; /**\n;;  * Positive predicate.\n;;\n;;  * @param {number} x - Number to check.\n;;  * @returns {boolean} #t if x is positive.\n;;  */\n(define (positive? x)\n  (if (not (number? x))\n      (error \"positive?: expected number\" x))\n  (> x 0))\n\n;; /**\n;;  * Negative predicate.\n;;\n;;  * @param {number} x - Number to check.\n;;  * @returns {boolean} #t if x is negative.\n;;  */\n(define (negative? x)\n  (if (not (number? x))\n      (error \"negative?: expected number\" x))\n  (< x 0))\n\n;; /**\n;;  * Odd predicate.\n;;\n;;  * @param {number} x - Integer to check.\n;;  * @returns {boolean} #t if x is odd.\n;;  */\n(define (odd? x)\n  (if (not (integer? x))\n      (error \"odd?: expected integer\" x))\n  (not (= (modulo x 2) 0)))\n\n;; /**\n;;  * Even predicate.\n;;\n;;  * @param {number} x - Integer to check.\n;;  * @returns {boolean} #t if x is even.\n;;  */\n(define (even? x)\n  (if (not (integer? x))\n      (error \"even?: expected integer\" x))\n  (= (modulo x 2) 0))\n\n;; =============================================================================\n;; Min/Max\n;; =============================================================================\n\n;; /**\n;;  * Maximum. Returns the largest of its arguments.\n;;\n;;  * @param {number} x - First number.\n;;  * @param {...number} rest - Additional numbers.\n;;  * @returns {number} Maximum value.\n;;  */\n(define (max x . rest)\n  (if (not (number? x))\n      (error \"max: expected number\" x))\n  (if (null? rest)\n      x\n      (let ((next (car rest)))\n        (if (not (number? next))\n            (error \"max: expected number\" next))\n        (apply max (if (> x next) x next) (cdr rest)))))\n\n;; /**\n;;  * Minimum. Returns the smallest of its arguments.\n;;\n;;  * @param {number} x - First number.\n;;  * @param {...number} rest - Additional numbers.\n;;  * @returns {number} Minimum value.\n;;  */\n(define (min x . rest)\n  (if (not (number? x))\n      (error \"min: expected number\" x))\n  (if (null? rest)\n      x\n      (let ((next (car rest)))\n        (if (not (number? next))\n            (error \"min: expected number\" next))\n        (apply min (if (< x next) x next) (cdr rest)))))\n\n;; =============================================================================\n;; GCD/LCM\n;; =============================================================================\n\n;; /**\n;;  * Greatest common divisor (binary helper).\n;;\n;;  * @param {integer} a - First integer.\n;;  * @param {integer} b - Second integer.\n;;  * @returns {integer} GCD of a and b.\n;;  */\n(define (%gcd2 a b)\n  (let ((aa (abs a))\n        (bb (abs b)))\n    (if (= bb 0)\n        aa\n        (%gcd2 bb (modulo aa bb)))))\n\n;; /**\n;;  * Greatest common divisor.\n;;\n;;  * @param {...integer} args - Integers.\n;;  * @returns {integer} GCD of all arguments, or 0 if no arguments.\n;;  */\n(define (gcd . args)\n  (for-each (lambda (x)\n              (if (not (integer? x))\n                  (error \"gcd: expected integer\" x)))\n            args)\n  (if (null? args)\n      0\n      (let loop ((result (abs (car args)))\n                 (rest (cdr args)))\n        (if (null? rest)\n            result\n            (loop (%gcd2 result (car rest)) (cdr rest))))))\n\n;; /**\n;;  * Least common multiple.\n;;\n;;  * @param {...integer} args - Integers.\n;;  * @returns {integer} LCM of all arguments, or 1 if no arguments.\n;;  */\n(define (lcm . args)\n  (for-each (lambda (x)\n              (if (not (integer? x))\n                  (error \"lcm: expected integer\" x)))\n            args)\n  (if (null? args)\n      1\n      (let loop ((result (abs (car args)))\n                 (rest (cdr args)))\n        (if (null? rest)\n            result\n            (let ((b (abs (car rest))))\n              (if (or (= result 0) (= b 0))\n                  0\n                  (loop (quotient (* result b) (%gcd2 result b))\n                        (cdr rest))))))))\n\n;; =============================================================================\n;; Rounding (R7RS banker's rounding)\n;; =============================================================================\n\n;; /**\n;;  * Round to nearest integer (R7RS: round half to even).\n;;\n;;  * @param {number} x - Number to round.\n;;  * @returns {number} Rounded value.\n;;  */\n(define (round x)\n  (if (not (number? x))\n      (error \"round: expected number\" x))\n  ;; Convert rational to inexact for arithmetic operations\n  (let ((x (if (rational? x) (inexact x) x)))\n    (let* ((fl (floor x))\n           (frac (- x fl)))\n      (cond\n        ((< frac 0.5) fl)\n        ((> frac 0.5) (+ fl 1))\n        ;; frac = 0.5, round to even\n        ((even? (inexact->exact fl)) fl)\n        (else (+ fl 1))))))\n\n;; Helper for round: convert inexact to exact (truncate to integer)\n(define (inexact->exact x)\n  (truncate x))\n",
  "parameter.scm": ";; R7RS Parameter Objects (ยง4.2.6)\n;;\n;; Implementation following SRFI-39 / R7RS section 7.3.\n;; Uses dynamic-wind for proper unwinding on control flow exit.\n\n;; =============================================================================\n;; Dynamic Environment\n;; =============================================================================\n\n;; objects to cells (pairs where the cdr holds the value).\n;; The global binding is stored directly in each parameter object.\n\n;; Use a box (list) to hold the environment so we can mutate the contents\n;; without changing the binding. This ensures multiple closures see the update.\n(define *param-dynamic-env-box* (list '()))\n\n;; /**\n;;  * Looks up a parameter in the dynamic environment.\n;;  * Returns the cell bound to the parameter, or the global cell if not found.\n;;  *\n;;  * @param {procedure} parameter - The parameter object.\n;;  * @param {pair} global-cell - The parameter's global cell.\n;;  * @returns {pair} The cell containing the current value.\n;;  */\n(define (param-dynamic-lookup parameter global-cell)\n  (let ((env (car *param-dynamic-env-box*)))\n    (let loop ((env env))\n      (cond ((null? env) global-cell)\n            ((eq? (caar env) parameter) (cdar env))\n            (else (loop (cdr env)))))))\n\n;; =============================================================================\n;; make-parameter\n;; =============================================================================\n\n;; /**\n;;  * Creates a new parameter object.\n;;  *\n;;  * The parameter object is a procedure that:\n;;  * - Called with no arguments: returns the current value\n;;  * - Called with one argument: sets the value (through converter) and returns unspecified\n;;  * - Called with two arguments: internal use for parameterize (returns converted value)\n;;  *\n;;  * @param {*} init - Initial value.\n;;  * @param {procedure} [converter] - Optional conversion procedure.\n;;  * @returns {procedure} The parameter object.\n;;  */\n(define (make-parameter init . conv)\n  (let ((converter (if (null? conv) \n                       (lambda (x) x) \n                       (car conv))))\n    ;; Global cell: (parameter . value)\n    ;; The car is set to the parameter itself for identity\n    (let ((global-cell (cons #f (converter init))))\n      (letrec ((parameter\n                (lambda args\n                  (let ((cell (param-dynamic-lookup parameter global-cell)))\n                    (cond \n                      ;; No arguments: return current value\n                      ((null? args) \n                       (cdr cell))\n                      ;; One argument: set the value\n                      ((null? (cdr args))\n                       (set-cdr! cell (converter (car args))))\n                      ;; Two arguments (internal): return converted value for parameterize\n                      (else \n                       (converter (car args))))))))\n        ;; Store parameter in car for potential debugging\n        (set-car! global-cell parameter)\n        parameter))))\n\n;; =============================================================================\n;; parameterize\n;; =============================================================================\n\n;; /**\n;;  * Binds parameters to values for the dynamic extent of body.\n;;  * Uses dynamic-wind to ensure proper restoration on exit.\n;;  *\n;;  * NOTE: This procedure is called by the parameterize macro and must be\n;;  * exported from the library. This is an implementation detail that will\n;;  * be unnecessary once we have proper referential transparency in macros.\n;;  *\n;;  * @param {list} params - List of parameter objects.\n;;  * @param {list} values - List of values to bind.\n;;  * @param {procedure} body - Thunk to execute.\n;;  * @returns {*} Result of body.\n;;  */\n(define (param-dynamic-bind params values body)\n  (let ((old-env (car *param-dynamic-env-box*)))\n    ;; Create new cells for each parameter with converted values\n    (let ((new-cells \n           (let loop ((ps params) (vs values) (cells '()))\n             (if (null? ps)\n                 (reverse cells)\n                 (loop (cdr ps) \n                       (cdr vs)\n                       ;; Call parameter with 2 args to get converted value\n                       (cons (cons (car ps) \n                                   (cons (car ps) ((car ps) (car vs) #f)))\n                             cells))))))\n      ;; Extend environment and use dynamic-wind for proper unwinding\n      (let ((new-env (append new-cells old-env)))\n        (dynamic-wind\n          (lambda () (set-car! *param-dynamic-env-box* new-env))\n          body\n          (lambda () (set-car! *param-dynamic-env-box* old-env)))))))\n\n;; /**\n;;  * Syntax for dynamic parameter binding.\n;;  *\n;;  * (parameterize ((param1 val1) (param2 val2) ...) body ...)\n;;  *\n;;  * Temporarily binds each parameter to its corresponding value\n;;  * for the dynamic extent of the body expressions.\n;;  */\n(define-syntax parameterize\n  (syntax-rules ()\n    ((parameterize () body ...)\n     (begin body ...))\n    ((parameterize ((param val) ...) body ...)\n     (param-dynamic-bind (list param ...)\n                         (list val ...)\n                         (lambda () body ...)))))\n",
  "process-context.sld": ";; (scheme process-context) library\n;;\n;; R7RS process context procedures.\n;; Some features are environment-specific (Node.js vs browser).\n\n(define-library (scheme process-context)\n  (import (scheme base))\n  (export command-line exit get-environment-variable get-environment-variables\n          emergency-exit)\n  (begin\n    ;; These are implemented as JS primitives that detect the environment\n    ;; and provide appropriate implementations.\n    \n    ;; Note: In browser environment, many of these will return\n    ;; empty/default values or be no-ops.\n    ))\n",
  "read.sld": ";; R7RS (scheme read) library\n;;\n;; Provides the read procedure for parsing S-expressions.\n;; Per R7RS ยง6.13.2.\n\n(define-library (scheme read)\n  (import (scheme primitives))\n  \n  (export read)\n  \n  (begin\n    ;; read is implemented as a primitive\n  ))\n",
  "repl.scm": ";; (scheme repl) implementation\n;; No extra definitions needed beyond what's in repl.sld\n",
  "repl.sld": ";; (scheme repl) library - R7RS standard\n;;\n;; Provides the interaction environment for REPL use.\n\n(define-library (scheme repl)\n  (import (scheme base))\n  (export interaction-environment)\n  (begin\n    ;; interaction-environment is already a primitive in our system\n    ;; so we just re-export it.\n  ))\n",
  "time.sld": ";; (scheme time) library\n;;\n;; R7RS time procedures using JavaScript Date.\n\n(define-library (scheme time)\n  (import (scheme base))\n  (export current-second current-jiffy jiffies-per-second)\n  (begin\n    ;; /**\n    ;;  * current-second - Returns current time as seconds since epoch.\n    ;;  * @returns {real} Seconds since 1970-01-01 00:00:00 UTC.\n    ;;  */\n    ;; Implemented as JS primitive\n    \n    ;; /**\n    ;;  * current-jiffy - Returns current time in jiffies.\n    ;;  * A jiffy is 1 millisecond in our implementation.\n    ;;  * @returns {integer} Current jiffy count.\n    ;;  */\n    ;; Implemented as JS primitive\n    \n    ;; /**\n    ;;  * jiffies-per-second - Returns the number of jiffies per second.\n    ;;  * @returns {integer} 1000 (milliseconds per second).\n    ;;  */\n    ;; Implemented as JS primitive\n    ))\n",
  "write.sld": ";; R7RS (scheme write) library\n;;\n;; Provides output procedures for formatted writing.\n;; Per R7RS ยง6.13.3.\n\n(define-library (scheme write)\n  (import (scheme primitives))\n  \n  (export\n    display\n    write\n    ;; write-shared and write-simple are optional extensions\n    ;; that we don't implement yet\n  )\n  \n  (begin\n    ;; Bindings come from primitives\n  ))\n",
  "interop.sld": ";; (scheme-js interop) library\n;;\n;; JavaScript interoperability primitives for Scheme.\n;; Provides js-eval, js-ref (property access), and js-set! (property mutation).\n\n(define-library (scheme-js interop)\n  (import (scheme base))\n  (export\n    js-eval\n    js-ref\n    js-set!\n    js-invoke\n    js-obj\n    js-obj-merge\n    js-typeof\n    js-undefined\n    js-undefined?))\n",
  "promise.scm": ";; JavaScript Promise Interoperability - Scheme Implementation\n;;\n;; This file provides the async-lambda macro which transforms\n;; code with await forms into CPS (Continuation-Passing Style).\n;;\n;; Example:\n;;   (async-lambda (url)\n;;     (let ((response (await (fetch url))))\n;;       (await (parse-json response))))\n;;\n;; Expands to:\n;;   (lambda (url)\n;;     (js-promise-then (fetch url)\n;;       (lambda (response)\n;;         (js-promise-then (parse-json response)\n;;           (lambda (v) v)))))\n\n;; ============================================================================\n;; async-lambda Macro\n;; ============================================================================\n\n;; /**\n;;  * async-lambda - Define a lambda that can use await to suspend on promises.\n;;  * \n;;  * Each (await expr) form becomes a promise-then boundary, transforming\n;;  * the remainder of the body into a continuation callback.\n;;  *\n;;  * @syntax (async-lambda (args ...) body ...)\n;;  * @returns {procedure} A procedure that returns a Promise\n;;  *\n;;  * LIMITATIONS:\n;;  * - call/cc captured BEFORE an await can escape the promise chain when invoked\n;;  * - call/cc captured AFTER an await only captures the current callback scope\n;;  * - TCO works within each callback segment, but not across await boundaries\n;;  */\n(define-syntax async-lambda\n  (syntax-rules ()\n    ;; Base case: body with no await - just return the value\n    ((async-lambda (args ...) body)\n     (lambda (args ...) (js-promise-resolve body)))\n    ;; Entry point for multiple expressions  \n    ((async-lambda (args ...) expr exprs ...)\n     (lambda (args ...)\n       (async-body expr exprs ...)))))\n\n;; /**\n;;  * async-body - Helper macro to process async body expressions.\n;;  * Transforms await forms to promise-then chains.\n;;  */\n(define-syntax async-body\n  (syntax-rules (await let)\n    ;; Single expression - wrap in resolved promise\n    ((async-body expr)\n     (js-promise-resolve expr))\n    ;; Let with await in binding - transform to promise-then\n    ((async-body (let ((var (await promise-expr))) body ...) rest ...)\n     (js-promise-then promise-expr\n       (lambda (var)\n         (async-body body ... rest ...))))\n    ;; Let without await - keep as is, continue processing\n    ((async-body (let ((var val)) body ...) rest ...)\n     (let ((var val))\n       (async-body body ... rest ...)))\n    ;; Non-let expression followed by more - sequence them\n    ((async-body expr rest ...)\n     (js-promise-then (js-promise-resolve expr)\n       (lambda (_)\n         (async-body rest ...))))))\n\n;; ============================================================================\n;; Promise Composition Utilities\n;; ============================================================================\n\n;; /**\n;;  * js-promise-map - Apply a function to the resolved value of a promise.\n;;  * @param {procedure} f - Function to apply\n;;  * @param {promise} p - Promise to map over\n;;  * @returns {promise} A new promise with the mapped value\n;;  */\n(define (js-promise-map f p)\n  (js-promise-then p f))\n\n;; /**\n;;  * js-promise-chain - Chain multiple promise-returning functions.\n;;  * @param {promise} p - Initial promise\n;;  * @param {procedure...} fs - Functions to chain (each takes a value, returns a promise)\n;;  * @returns {promise} Final promise in the chain\n;;  */\n(define (js-promise-chain p . fs)\n  (if (null? fs)\n      p\n      (apply js-promise-chain \n             (js-promise-then p (car fs))\n             (cdr fs))))\n\n\n",
  "promise.sld": ";; (scheme-js promise) library\n;;\n;; JavaScript Promise interoperability for Scheme.\n;; Provides primitives and macros for working with JavaScript Promises\n;; in a CPS-style that preserves TCO within callback segments.\n\n(define-library (scheme-js promise)\n  (import (scheme base))\n  (export \n    ;; Predicates\n    js-promise?\n    ;; Constructors\n    make-js-promise\n    js-promise-resolve\n    js-promise-reject\n    ;; Combinators\n    js-promise-then\n    js-promise-catch\n    js-promise-finally\n    js-promise-all\n    js-promise-race\n    js-promise-all-settled\n    ;; Scheme utilities\n    js-promise-map\n    js-promise-chain\n    ;; Macro for CPS transformation\n    async-lambda)\n  (include \"promise.scm\"))\n"
};
